### 💡알고리즘 분류 : 누적합 

---

### ✅ 풀이

⭐️ **sum[i] - sum[j] 는 i+1 부터 j 번 인덱스까지의 합과 같다.** 

⭐️ **Key Idea :** 

- sum[i] - k  인 값이 sum 배열에 존재한다면 → 부분합이 K 인 경우가 존재한다는 걸 떠올릴 수 있어야 했다. 

- **sum 배열에 존재한다는 것은 map 에 저장된 값을 통해 확인한다.**


### 🔎로직 설명

*sum = 누적합 배열 

*map = 누적합 배열에서 나타난 값의 빈도 저장 (key : 합의 값, value : 빈도) 

**1. 입력을 받음과 동시에 sum 배열 업데이트**
    
    sum[i] = 1번부터 i번 까지의 합 
    
    sum[i] = k 라면, 바로 result += 1 
    
**2. i = 1 부터 n 까지 반복**
    
    sum[i] - k 인 값이 존재 했다면 → map m 에 저장되어 있을 것이므로 그 값을 업데이트 
    
    map m 에 sum[i] 의 빈도 업데이트 



**예제 입력 1 로 예를 들면 :** 

k = 0, 

입력 = 2, -2, 2, -2

**1. sum 배열 업데이트**
    
    sum[1] = 2 
    
    sum[2] = sum[1] + (-2) = 0 → `result = 1`
    
    sum[3] = sum[2] + 2 = 2 
    
    sum[4] = sum[3] - 2 = 0 → `result = 2`
    
**2. i = 1 부터 4 까지 반복**

    1. i = 1 일 때 :
        
        sum[1] - k = 2 - 0 = 2 
        
        map[2] 업데이트 한 적 없음  → `result = 2 + 0 = 2`
        
        map[2] = 1 로 업데이트
        
    2. i = 2 일 때 :
        
        sum[2] - k = 0 - 0 = 0 
        
        map[0] 업데이트 한 적 없음  → `result = 2 + 0 = 2`
        
        map[0] = 1 로 업데이트 
        
    3. i = 3 일 때 : 
        
        sum[3] - k = 2 - 0 = 2
        
        map[2] = 1 이므로 → `result = 2 + 1 = 3`
        
        map[2] = 2 로 업데이트 
        
    4. i = 4 일 때 : 
        
        sum[4] - k = 0 - 0 = 0
        
        map[0] = 1 이므로 → `result = 3 + 1 = 4`
        
        map[0] = 2 로 업데이트 

---

### 📌 어려웠던 이유

- 누적합 알고리즘을 생각하지 못했음
- N ≤ 200,000 → for 문 하나만 써야한다까지는 떠올렸는데 아무리 생각해도 한 번의 루프로 돌아서 해결하는 방법을 모르겠음
