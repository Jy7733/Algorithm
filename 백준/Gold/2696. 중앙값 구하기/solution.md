### 💡알고리즘 분류
---

- 자료구조
- 우선순위 큐

### 🔎 접근 방법

---

**사고 과정 ⬇️** 

1. **새로운 원소값을 넣을 때마다 sort 하는 방법** 
    
    → 시간 복잡도가 1*log(1) * 2*log(2) * …9999*log(9999) ⇒ 시간초과가 날 것 같다. 
    
2. **자동 정렬되는 자료구조를 사용해야 하나?** 
    
    → priority queue ⇒ 근데 queue 는 인덱스로 접근이 불가능한데 어떻게 해야 할까
    
    → 그리고 priority queue 로 매번 정렬한다면 시간초과가 나지 않을까?! 
    
3. **🔑 중앙값 들어갈 자리에서 양 옆 값만 확인하면 좀 더 빠르게 할 수 있을 것 같다!!!**
    
    → 중앙값보다 작은 값들 → Left 큐에 모아 놓기
    
    → 중앙값보다 큰 값들 → Right 큐에 모아 놓기 
    
    ⇒ 홀 수 번째 자리에서 받은 input 값을 Left 의 top (left 중 가장 큰 값) 과 Right 의 top(right 중 가장 작은 값) 만이랑 비교하면 됨! 
    
    + 전체 배열이 아닌 더 작은 개수의 원소들만 정렬하면 됨
    

### ✅ 풀이

---

1. **첫 번째 값**은 그 값 자체가 중앙값이므로 mid 값으로 설정하고, result 배열에 삽입
2. **짝수 번째** 값은 
    1. (이전 순서의) mid 값 보다 크면 
        
        → Right 큐로 
        
        → mid 값은 Left 큐로 
        
    2. (이전 순서의) mid 값 보다 작으면 
        
        → Left 큐로 
        
        → mid 값은 Right 큐로 
        
    
    만약 첫 번째 값이 1이었고 다음으로 들어온 값이 5 였다면 
    
    mid = 1 < 5 → Left = {1}, Right = {5}
    
3. **홀수 번째** 값은 
    1. Left 큐에 저장된 값 중 가장 큰 수(=leftTop) 보다 작다면 
        
        → Left 큐에 삽입
        
        → mid 값은 leftTop 이 됨
        
    2. Right 큐에 저장된 값 중 가장 작은 수(=rightTop) 보다 크다면 
        
        → Right 큐에 삽입
        
        → mid 값은 rightTop 이 됨
        
    3. leftTop 과 rightTop 의 중간이라면 입력값이 중앙값이 되므로 
        
        → mid = input 값
